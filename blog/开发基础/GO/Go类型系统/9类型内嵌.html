<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>类型内嵌 | 一名PHP+GO工程师</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    
    <link rel="preload" href="/blog/assets/css/0.styles.b3aba94c.css" as="style"><link rel="preload" href="/blog/assets/js/app.4c58f1db.js" as="script"><link rel="preload" href="/blog/assets/js/3.a4fcd0ee.js" as="script"><link rel="preload" href="/blog/assets/js/117.037382b2.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.835fec01.js"><link rel="prefetch" href="/blog/assets/js/100.dc00317a.js"><link rel="prefetch" href="/blog/assets/js/101.7eebede9.js"><link rel="prefetch" href="/blog/assets/js/102.82f3c447.js"><link rel="prefetch" href="/blog/assets/js/103.eab9003e.js"><link rel="prefetch" href="/blog/assets/js/104.10bc5a69.js"><link rel="prefetch" href="/blog/assets/js/105.4ab84c31.js"><link rel="prefetch" href="/blog/assets/js/106.48a2438e.js"><link rel="prefetch" href="/blog/assets/js/107.cc68b4a0.js"><link rel="prefetch" href="/blog/assets/js/108.a8d052c3.js"><link rel="prefetch" href="/blog/assets/js/109.2cc1bd1b.js"><link rel="prefetch" href="/blog/assets/js/11.2975610c.js"><link rel="prefetch" href="/blog/assets/js/110.8f8186a2.js"><link rel="prefetch" href="/blog/assets/js/111.eaf08c2f.js"><link rel="prefetch" href="/blog/assets/js/112.c4fa3638.js"><link rel="prefetch" href="/blog/assets/js/113.2b4447c9.js"><link rel="prefetch" href="/blog/assets/js/114.04ffca65.js"><link rel="prefetch" href="/blog/assets/js/115.e5496f96.js"><link rel="prefetch" href="/blog/assets/js/116.4a8c606f.js"><link rel="prefetch" href="/blog/assets/js/118.5bb91c57.js"><link rel="prefetch" href="/blog/assets/js/119.09db3f3b.js"><link rel="prefetch" href="/blog/assets/js/12.a764b57a.js"><link rel="prefetch" href="/blog/assets/js/120.b24a6d4e.js"><link rel="prefetch" href="/blog/assets/js/121.ca19b1f3.js"><link rel="prefetch" href="/blog/assets/js/122.561ef8e8.js"><link rel="prefetch" href="/blog/assets/js/123.f0e374e2.js"><link rel="prefetch" href="/blog/assets/js/124.e9989260.js"><link rel="prefetch" href="/blog/assets/js/125.b0f30b2f.js"><link rel="prefetch" href="/blog/assets/js/126.1a1939b5.js"><link rel="prefetch" href="/blog/assets/js/127.e2142582.js"><link rel="prefetch" href="/blog/assets/js/128.a6a813a1.js"><link rel="prefetch" href="/blog/assets/js/129.bf107fcf.js"><link rel="prefetch" href="/blog/assets/js/13.3adc8648.js"><link rel="prefetch" href="/blog/assets/js/130.130b9782.js"><link rel="prefetch" href="/blog/assets/js/131.b153558f.js"><link rel="prefetch" href="/blog/assets/js/132.2472d0a5.js"><link rel="prefetch" href="/blog/assets/js/133.549915cc.js"><link rel="prefetch" href="/blog/assets/js/134.5b06b412.js"><link rel="prefetch" href="/blog/assets/js/135.95e51dda.js"><link rel="prefetch" href="/blog/assets/js/136.1d13c0e3.js"><link rel="prefetch" href="/blog/assets/js/137.a6b4615c.js"><link rel="prefetch" href="/blog/assets/js/138.738cf96b.js"><link rel="prefetch" href="/blog/assets/js/139.d897ac9a.js"><link rel="prefetch" href="/blog/assets/js/14.a3b148c6.js"><link rel="prefetch" href="/blog/assets/js/140.270aba65.js"><link rel="prefetch" href="/blog/assets/js/141.e1f2d4d3.js"><link rel="prefetch" href="/blog/assets/js/142.2ff02945.js"><link rel="prefetch" href="/blog/assets/js/143.c72c097b.js"><link rel="prefetch" href="/blog/assets/js/144.dc000941.js"><link rel="prefetch" href="/blog/assets/js/145.c82275d5.js"><link rel="prefetch" href="/blog/assets/js/146.4aebd6b1.js"><link rel="prefetch" href="/blog/assets/js/147.0287686c.js"><link rel="prefetch" href="/blog/assets/js/148.b0bca954.js"><link rel="prefetch" href="/blog/assets/js/149.15a2e786.js"><link rel="prefetch" href="/blog/assets/js/15.6bfd2036.js"><link rel="prefetch" href="/blog/assets/js/150.2cfeb60d.js"><link rel="prefetch" href="/blog/assets/js/151.c359177f.js"><link rel="prefetch" href="/blog/assets/js/152.19a86bd8.js"><link rel="prefetch" href="/blog/assets/js/153.4159b600.js"><link rel="prefetch" href="/blog/assets/js/154.121f5cc3.js"><link rel="prefetch" href="/blog/assets/js/155.97708bc3.js"><link rel="prefetch" href="/blog/assets/js/156.f9c6bcdd.js"><link rel="prefetch" href="/blog/assets/js/157.6755fc50.js"><link rel="prefetch" href="/blog/assets/js/158.479651f6.js"><link rel="prefetch" href="/blog/assets/js/159.031af42e.js"><link rel="prefetch" href="/blog/assets/js/16.62be6808.js"><link rel="prefetch" href="/blog/assets/js/160.ec9dd64d.js"><link rel="prefetch" href="/blog/assets/js/161.bc8dd162.js"><link rel="prefetch" href="/blog/assets/js/162.2b87186a.js"><link rel="prefetch" href="/blog/assets/js/163.5efb49e5.js"><link rel="prefetch" href="/blog/assets/js/164.7b79d6e9.js"><link rel="prefetch" href="/blog/assets/js/165.c0887522.js"><link rel="prefetch" href="/blog/assets/js/166.59b3fd1e.js"><link rel="prefetch" href="/blog/assets/js/167.3350e62a.js"><link rel="prefetch" href="/blog/assets/js/168.305d6c4c.js"><link rel="prefetch" href="/blog/assets/js/169.1e7bb107.js"><link rel="prefetch" href="/blog/assets/js/17.380ba58f.js"><link rel="prefetch" href="/blog/assets/js/170.a5ef964f.js"><link rel="prefetch" href="/blog/assets/js/171.c65fb717.js"><link rel="prefetch" href="/blog/assets/js/172.449d2311.js"><link rel="prefetch" href="/blog/assets/js/173.83f97e48.js"><link rel="prefetch" href="/blog/assets/js/174.3eca4f09.js"><link rel="prefetch" href="/blog/assets/js/175.9fc6896e.js"><link rel="prefetch" href="/blog/assets/js/176.2036b264.js"><link rel="prefetch" href="/blog/assets/js/177.5b0117fa.js"><link rel="prefetch" href="/blog/assets/js/178.65b256f2.js"><link rel="prefetch" href="/blog/assets/js/179.f26bcc6c.js"><link rel="prefetch" href="/blog/assets/js/18.5cc6f3a7.js"><link rel="prefetch" href="/blog/assets/js/180.0f225157.js"><link rel="prefetch" href="/blog/assets/js/181.680ac14a.js"><link rel="prefetch" href="/blog/assets/js/182.3edee8c1.js"><link rel="prefetch" href="/blog/assets/js/183.2ad4dd90.js"><link rel="prefetch" href="/blog/assets/js/19.a5c2b897.js"><link rel="prefetch" href="/blog/assets/js/2.c8a68b51.js"><link rel="prefetch" href="/blog/assets/js/20.dba1906e.js"><link rel="prefetch" href="/blog/assets/js/21.eb95247a.js"><link rel="prefetch" href="/blog/assets/js/22.0dc20366.js"><link rel="prefetch" href="/blog/assets/js/23.216a8421.js"><link rel="prefetch" href="/blog/assets/js/24.2710df9d.js"><link rel="prefetch" href="/blog/assets/js/25.a628a83e.js"><link rel="prefetch" href="/blog/assets/js/26.c8cc9490.js"><link rel="prefetch" href="/blog/assets/js/27.b6aa595b.js"><link rel="prefetch" href="/blog/assets/js/28.e9bc0181.js"><link rel="prefetch" href="/blog/assets/js/29.dd1ae43d.js"><link rel="prefetch" href="/blog/assets/js/30.d695ccf7.js"><link rel="prefetch" href="/blog/assets/js/31.32df4d02.js"><link rel="prefetch" href="/blog/assets/js/32.0fffbc5f.js"><link rel="prefetch" href="/blog/assets/js/33.6b3bbf30.js"><link rel="prefetch" href="/blog/assets/js/34.b4c3eaa1.js"><link rel="prefetch" href="/blog/assets/js/35.76a8a203.js"><link rel="prefetch" href="/blog/assets/js/36.4d6733d9.js"><link rel="prefetch" href="/blog/assets/js/37.95ddd62d.js"><link rel="prefetch" href="/blog/assets/js/38.d92a014e.js"><link rel="prefetch" href="/blog/assets/js/39.c6e76213.js"><link rel="prefetch" href="/blog/assets/js/4.e9a98dae.js"><link rel="prefetch" href="/blog/assets/js/40.8c0ce826.js"><link rel="prefetch" href="/blog/assets/js/41.33b0fa25.js"><link rel="prefetch" href="/blog/assets/js/42.96f29d4d.js"><link rel="prefetch" href="/blog/assets/js/43.4ed5ff9c.js"><link rel="prefetch" href="/blog/assets/js/44.77353d4f.js"><link rel="prefetch" href="/blog/assets/js/45.ab5daeac.js"><link rel="prefetch" href="/blog/assets/js/46.8adfc6dd.js"><link rel="prefetch" href="/blog/assets/js/47.2ae15dfc.js"><link rel="prefetch" href="/blog/assets/js/48.31ba75e5.js"><link rel="prefetch" href="/blog/assets/js/49.49e438b2.js"><link rel="prefetch" href="/blog/assets/js/5.5ec4d71f.js"><link rel="prefetch" href="/blog/assets/js/50.f8254ac5.js"><link rel="prefetch" href="/blog/assets/js/51.90ad6773.js"><link rel="prefetch" href="/blog/assets/js/52.b5da9d10.js"><link rel="prefetch" href="/blog/assets/js/53.82345eb5.js"><link rel="prefetch" href="/blog/assets/js/54.f93a6f8d.js"><link rel="prefetch" href="/blog/assets/js/55.dd6d8ef8.js"><link rel="prefetch" href="/blog/assets/js/56.63add859.js"><link rel="prefetch" href="/blog/assets/js/57.bd76cf23.js"><link rel="prefetch" href="/blog/assets/js/58.25135cb4.js"><link rel="prefetch" href="/blog/assets/js/59.ecd67516.js"><link rel="prefetch" href="/blog/assets/js/6.84e1b999.js"><link rel="prefetch" href="/blog/assets/js/60.23e89841.js"><link rel="prefetch" href="/blog/assets/js/61.68d9cb1f.js"><link rel="prefetch" href="/blog/assets/js/62.d1b8d952.js"><link rel="prefetch" href="/blog/assets/js/63.1d640eca.js"><link rel="prefetch" href="/blog/assets/js/64.32167475.js"><link rel="prefetch" href="/blog/assets/js/65.f7a24ac5.js"><link rel="prefetch" href="/blog/assets/js/66.5a4ad07b.js"><link rel="prefetch" href="/blog/assets/js/67.5abe04b4.js"><link rel="prefetch" href="/blog/assets/js/68.4bd07a6f.js"><link rel="prefetch" href="/blog/assets/js/69.61cefde7.js"><link rel="prefetch" href="/blog/assets/js/7.be512878.js"><link rel="prefetch" href="/blog/assets/js/70.d884d460.js"><link rel="prefetch" href="/blog/assets/js/71.6346d932.js"><link rel="prefetch" href="/blog/assets/js/72.669b09d5.js"><link rel="prefetch" href="/blog/assets/js/73.c1d8c39c.js"><link rel="prefetch" href="/blog/assets/js/74.36016cfd.js"><link rel="prefetch" href="/blog/assets/js/75.fb7d7a96.js"><link rel="prefetch" href="/blog/assets/js/76.ba71ac91.js"><link rel="prefetch" href="/blog/assets/js/77.651eea09.js"><link rel="prefetch" href="/blog/assets/js/78.9993efdc.js"><link rel="prefetch" href="/blog/assets/js/79.816d277e.js"><link rel="prefetch" href="/blog/assets/js/8.93ccc70d.js"><link rel="prefetch" href="/blog/assets/js/80.e39860ed.js"><link rel="prefetch" href="/blog/assets/js/81.77799baa.js"><link rel="prefetch" href="/blog/assets/js/82.9b8b2e5c.js"><link rel="prefetch" href="/blog/assets/js/83.1ae8f42d.js"><link rel="prefetch" href="/blog/assets/js/84.ffb238f7.js"><link rel="prefetch" href="/blog/assets/js/85.238317c1.js"><link rel="prefetch" href="/blog/assets/js/86.badce18f.js"><link rel="prefetch" href="/blog/assets/js/87.bf03f5f0.js"><link rel="prefetch" href="/blog/assets/js/88.817f8a13.js"><link rel="prefetch" href="/blog/assets/js/89.3b6fc0d2.js"><link rel="prefetch" href="/blog/assets/js/9.aba0f006.js"><link rel="prefetch" href="/blog/assets/js/90.c08fced7.js"><link rel="prefetch" href="/blog/assets/js/91.247d2df4.js"><link rel="prefetch" href="/blog/assets/js/92.8b0a6fda.js"><link rel="prefetch" href="/blog/assets/js/93.be593c08.js"><link rel="prefetch" href="/blog/assets/js/94.27fd5c80.js"><link rel="prefetch" href="/blog/assets/js/95.021cdc5a.js"><link rel="prefetch" href="/blog/assets/js/96.e1d5c9c7.js"><link rel="prefetch" href="/blog/assets/js/97.b3e60c1f.js"><link rel="prefetch" href="/blog/assets/js/98.73459e19.js"><link rel="prefetch" href="/blog/assets/js/99.737e92f6.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.b3aba94c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">一名PHP+GO工程师</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://gitee.com/ColinWWL/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://gitee.com/ColinWWL/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  码云Gitee
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/Go类型系统/1Go类型系统概述" class="sidebar-heading clickable open"><span>Go类型系统</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/Go类型系统/1Go类型系统概述.html" class="sidebar-link">Go类型系统概述</a></li><li><a href="/blog/开发基础/GO/Go类型系统/2指针.html" class="sidebar-link">指针</a></li><li><a href="/blog/开发基础/GO/Go类型系统/3结构体.html" class="sidebar-link">结构体</a></li><li><a href="/blog/开发基础/GO/Go类型系统/4值部.html" class="sidebar-link">值部</a></li><li><a href="/blog/开发基础/GO/Go类型系统/5数组、切片和映射.html" class="sidebar-link">数组、切片和映射</a></li><li><a href="/blog/开发基础/GO/Go类型系统/6通道.html" class="sidebar-link">通道</a></li><li><a href="/blog/开发基础/GO/Go类型系统/7方法.html" class="sidebar-link">方法</a></li><li><a href="/blog/开发基础/GO/Go类型系统/8接口.html" class="sidebar-link">接口</a></li><li><a href="/blog/开发基础/GO/Go类型系统/9类型内嵌.html" class="active sidebar-link">类型内嵌</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/Go类型系统/9类型内嵌.html#类型内嵌语法" class="sidebar-link">类型内嵌语法</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/Go类型系统/9类型内嵌.html#哪些类型可以被内嵌" class="sidebar-link">哪些类型可以被内嵌？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/Go类型系统/9类型内嵌.html#类型内嵌的意义是什么" class="sidebar-link">类型内嵌的意义是什么？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/Go类型系统/9类型内嵌.html#当一个结构体类型内嵌了另一个类型-此结构体类型是否获取了被内嵌类型的字段和方法" class="sidebar-link">当一个结构体类型内嵌了另一个类型，此结构体类型是否获取了被内嵌类型的字段和方法？</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/Go类型系统/9类型内嵌.html#选择器的缩写形式" class="sidebar-link">选择器的缩写形式</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/Go类型系统/9类型内嵌.html#选择器遮挡和碰撞" class="sidebar-link">选择器遮挡和碰撞</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/Go类型系统/9类型内嵌.html#为内嵌了其它类型的结构体类型声明的隐式方法" class="sidebar-link">为内嵌了其它类型的结构体类型声明的隐式方法</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/Go类型系统/9类型内嵌.html#接口类型内嵌接口类型" class="sidebar-link">接口类型内嵌接口类型</a></li><li class="sidebar-sub-header"><a href="/blog/开发基础/GO/Go类型系统/9类型内嵌.html#一个有趣的类型内嵌的例子" class="sidebar-link">一个有趣的类型内嵌的例子</a></li></ul></li><li><a href="/blog/开发基础/GO/Go类型系统/10非类型安全指针.html" class="sidebar-link">非类型安全指针</a></li><li><a href="/blog/开发基础/GO/Go类型系统/11泛型.html" class="sidebar-link">泛型</a></li><li><a href="/blog/开发基础/GO/Go类型系统/12反射.html" class="sidebar-link">反射</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/Go编程入门/1程序源代码基本元素介绍" class="sidebar-heading clickable"><span>Go编程入门</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/Go编程入门/1程序源代码基本元素介绍.html" class="sidebar-link">程序源代码基本元素介绍</a></li><li><a href="/blog/开发基础/GO/Go编程入门/2关键字和标识符.html" class="sidebar-link">关键字和标识符</a></li><li><a href="/blog/开发基础/GO/Go编程入门/3基本类型和它们的字面量表示.html" class="sidebar-link">基本类型和它们的字面量表示</a></li><li><a href="/blog/开发基础/GO/Go编程入门/4常量和变量.html" class="sidebar-link">常量和变量</a></li><li><a href="/blog/开发基础/GO/Go编程入门/5运算操作符.html" class="sidebar-link">运算操作符</a></li><li><a href="/blog/开发基础/GO/Go编程入门/6函数声明和调用.html" class="sidebar-link">函数声明和调用</a></li><li><a href="/blog/开发基础/GO/Go编程入门/7代码包和包引入.html" class="sidebar-link">代码包和包引入</a></li><li><a href="/blog/开发基础/GO/Go编程入门/8表达式、语句和简单语句.html" class="sidebar-link">表达式、语句和简单语句</a></li><li><a href="/blog/开发基础/GO/Go编程入门/9基本流程控制语法.html" class="sidebar-link">基本流程控制语法</a></li><li><a href="/blog/开发基础/GO/Go编程入门/10协程、延迟函数调用、以及恐慌和恢复.html" class="sidebar-link">协程、延迟函数调用、以及恐慌和恢复</a></li><li><a href="/blog/开发基础/GO/Go编程入门/GO官方链接工具.html" class="sidebar-link">GO官方链接工具</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/其他文章/Go技巧" class="sidebar-heading clickable"><span>其他文章</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/其他文章/Go技巧.html" class="sidebar-link">Go技巧</a></li><li><a href="/blog/开发基础/GO/其他文章/Go细节.html" class="sidebar-link">Go细节</a></li><li><a href="/blog/开发基础/GO/其他文章/Go问答.html" class="sidebar-link">Go问答</a></li><li><a href="/blog/开发基础/GO/其他文章/命令-mod.html" class="sidebar-link">命令-mod</a></li><li><a href="/blog/开发基础/GO/其他文章/基础-Golang的time.NewTimer单次定时器使用案例.html" class="sidebar-link">基础-Golang的time. NewTimer单次定时器使用案例</a></li><li><a href="/blog/开发基础/GO/其他文章/基础-Go中的nil.html" class="sidebar-link">Go中的 nil</a></li><li><a href="/blog/开发基础/GO/其他文章/基础-Go代码断行规则.html" class="sidebar-link">Go代码断行规则</a></li><li><a href="/blog/开发基础/GO/其他文章/基础-表达式估值顺序规则.html" class="sidebar-link">表达式估值顺序规则</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/学习资料" class="sidebar-heading clickable"><span>GO</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/学习资料.html" class="sidebar-link">教学书籍</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/并发编程/1并发同步概述" class="sidebar-heading clickable"><span>并发编程</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/并发编程/1并发同步概述.html" class="sidebar-link">并发同步概述</a></li><li><a href="/blog/开发基础/GO/并发编程/2通道用例大全.html" class="sidebar-link">通道用例大全</a></li><li><a href="/blog/开发基础/GO/并发编程/3如何优雅地关闭通道.html" class="sidebar-link">如何优雅地关闭通道</a></li><li><a href="/blog/开发基础/GO/并发编程/4其它并发同步技术.html" class="sidebar-link">sync 标准库包中提供的并发同步技术</a></li><li><a href="/blog/开发基础/GO/并发编程/5原子操作 .html" class="sidebar-link">sync/atomic 标准库包中提供的原子操作</a></li><li><a href="/blog/开发基础/GO/并发编程/6Go中的内存顺序保证.html" class="sidebar-link">Go中的内存顺序保证</a></li><li><a href="/blog/开发基础/GO/并发编程/7一些常见并发编程错误.html" class="sidebar-link">一些常见并发编程错误</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/blog/开发基础/GO/开发环境搭建/Docker和VS Code的Go开发环境" class="sidebar-heading clickable"><span>开发环境搭建</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/开发基础/GO/开发环境搭建/Docker和VS Code的Go开发环境.html" class="sidebar-link">Docker和VS Code的Go开发环境</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="类型内嵌"><a href="#类型内嵌" class="header-anchor">#</a> 类型内嵌</h1> <p>从<a href="https://gfw.go101.org/article/struct.html" target="_blank" rel="noopener noreferrer">结构体<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一文中，我们得知一个结构体类型可以拥有若干字段。 每个字段由一个字段名和一个字段类型组成。事实上，有时，一个字段可以仅由一个字段类型组成。 这样的字段声明方式称为类型内嵌（type embedding）。</p> <p>此篇文章将解释类型内嵌的目的和各种和类型内嵌相关的细节。</p> <h2 id="类型内嵌语法"><a href="#类型内嵌语法" class="header-anchor">#</a> 类型内嵌语法</h2> <p>下面是一个使用了类型内嵌的例子：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">&quot;net/http&quot;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">type</span> P <span class="token operator">=</span> <span class="token operator">*</span><span class="token builtin">bool</span>
	<span class="token keyword">type</span> M <span class="token operator">=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span>
	<span class="token keyword">var</span> x <span class="token keyword">struct</span> <span class="token punctuation">{</span>
		<span class="token builtin">string</span> <span class="token comment">// 一个定义的非指针类型</span>
		<span class="token builtin">error</span>  <span class="token comment">// 一个定义的接口类型</span>
		<span class="token operator">*</span><span class="token builtin">int</span>   <span class="token comment">// 一个非定义指针类型</span>
		P      <span class="token comment">// 一个非定义指针类型的别名</span>
		M      <span class="token comment">// 一个非定义类型的别名</span>

		http<span class="token punctuation">.</span>Header <span class="token comment">// 一个定义的映射类型</span>
	<span class="token punctuation">}</span>
	x<span class="token punctuation">.</span><span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">&quot;Go&quot;</span>
	x<span class="token punctuation">.</span><span class="token builtin">error</span> <span class="token operator">=</span> <span class="token boolean">nil</span>
	x<span class="token punctuation">.</span><span class="token builtin">int</span> <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span>
	x<span class="token punctuation">.</span>P <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token builtin">bool</span><span class="token punctuation">)</span>
	x<span class="token punctuation">.</span>M <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span>M<span class="token punctuation">)</span>
	x<span class="token punctuation">.</span>Header <span class="token operator">=</span> http<span class="token punctuation">.</span>Header<span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在上面这个例子中，有六个类型被内嵌在了一个结构体类型中。每个类型内嵌形成了一个内嵌字段（embedded field）。</p> <p>因为历史原因，内嵌字段有时也称为匿名字段。但是，事实上，每个内嵌字段有一个（隐式的）名字。 此字段的<a href="https://golang.google.cn/ref/spec#Qualified_identifiers" target="_blank" rel="noopener noreferrer">非限定（unqualified）<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>类型名即为此字段的名称。 比如，上例中的六个内嵌字段的名称分别为 <code>string</code> 、 <code>error</code> 、 <code>int</code> 、 <code>P</code> 、 <code>M</code> 和 <code>Header</code> 。</p> <h2 id="哪些类型可以被内嵌"><a href="#哪些类型可以被内嵌" class="header-anchor">#</a> 哪些类型可以被内嵌？</h2> <p>当前的Go白皮书（1.16）<a href="https://golang.google.cn/ref/spec#Struct_types" target="_blank" rel="noopener noreferrer">规定<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：</p> <blockquote><p>An embedded field must be specified as a type name <code>T</code> or as a pointer to a non-interface type name <code>*T</code> , and <code>T</code> itself may not be a pointer type.</p></blockquote> <p>翻译过来：</p> <blockquote><p>一个内嵌字段必须被声明为形式 <code>T</code> 或者一个基类型为非接口类型的指针类型 <code>*T</code> ，其中 <code>T</code> 为一个类型名但是 <code>T</code> 不能表示一个指针类型。</p></blockquote> <p>此规则描述在Go 1.9之前是精确的。但是随着从Go 1.9引入的自定义类型别名概念，此描述<a href="https://github.com/golang/go/issues/22005" target="_blank" rel="noopener noreferrer">有些过时和不太准确了<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。 比如，此描述没有包括上一节的例子中的 <code>P</code> 内嵌字段的情形。</p> <p>这里，本文试图使用一个更精确的描述：</p> <ul><li>一个类型名<code>T</code>只有在它既不表示一个定义的指针类型也不表示一个基类型为指针类型或者接口类型的指针类型的情况下才可以被用作内嵌字段。</li> <li>一个指针类型<code>*T</code>只有在<code>T</code>为一个类型名并且<code>T</code>既不表示一个指针类型也不表示一个接口类型的时候才能被用作内嵌字段。</li></ul> <p>下面列出了一些可以被或不可以被内嵌的类型或别名：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">type</span> Encoder <span class="token keyword">interface</span> <span class="token punctuation">{</span><span class="token function">Encode</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">}</span>
<span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">{</span>name <span class="token builtin">string</span><span class="token punctuation">;</span> age <span class="token builtin">int</span><span class="token punctuation">}</span>
<span class="token keyword">type</span> Alias <span class="token operator">=</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>name <span class="token builtin">string</span><span class="token punctuation">;</span> age <span class="token builtin">int</span><span class="token punctuation">}</span>
<span class="token keyword">type</span> AliasPtr <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">struct</span> <span class="token punctuation">{</span>name <span class="token builtin">string</span><span class="token punctuation">;</span> age <span class="token builtin">int</span><span class="token punctuation">}</span>
<span class="token keyword">type</span> IntPtr <span class="token operator">*</span><span class="token builtin">int</span>
<span class="token keyword">type</span> AliasPP <span class="token operator">=</span> <span class="token operator">*</span>IntPtr

<span class="token comment">// 这些类型或别名都可以被内嵌。</span>
Encoder
Person
<span class="token operator">*</span>Person
Alias
<span class="token operator">*</span>Alias
AliasPtr
<span class="token builtin">int</span>
<span class="token operator">*</span><span class="token builtin">int</span>

<span class="token comment">// 这些类型或别名都不能被内嵌。</span>
AliasPP          <span class="token comment">// 基类型为一个指针类型</span>
<span class="token operator">*</span>Encoder         <span class="token comment">// 基类型为一个接口类型</span>
<span class="token operator">*</span>AliasPtr        <span class="token comment">// 基类型为一个指针类型</span>
IntPtr           <span class="token comment">// 定义的指针类型</span>
<span class="token operator">*</span>IntPtr          <span class="token comment">// 基类型为一个指针类型</span>
<span class="token operator">*</span><span class="token keyword">chan</span> <span class="token builtin">int</span>        <span class="token comment">// 基类型为一个非定义类型</span>
<span class="token keyword">struct</span> <span class="token punctuation">{</span>age <span class="token builtin">int</span><span class="token punctuation">}</span> <span class="token comment">// 非定义非指针类型</span>
<span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span>   <span class="token comment">// 非定义非指针类型</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int64</span>          <span class="token comment">// 非定义非指针类型</span>
<span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token comment">// 非定义非指针类型</span>
</code></pre></div><p>一个结构体类型中不允许有两个同名字段，此规则对匿名字段同样适用。 根据上述内嵌字段的隐含名称规则，一个非定义指针类型不能和它的基类型同时内嵌在同一个结构体类型中。 比如， <code>int</code> 和 <code>*int</code> 类型不能同时内嵌在同一个结构体类型中。</p> <p>一个结构体类型不能内嵌（无论间接还是直接）它自己。</p> <p>一般说来，只有内嵌含有字段或者拥有方法的类型才有意义（后续几节将阐述原因），尽管很多既没有字段也没有方法的类型也可以被内嵌。</p> <h2 id="类型内嵌的意义是什么"><a href="#类型内嵌的意义是什么" class="header-anchor">#</a> 类型内嵌的意义是什么？</h2> <p>类型内嵌的主要目的是为了将被内嵌类型的功能扩展到内嵌它的结构体类型中，从而我们不必再为此结构体类型重复实现被内嵌类型的功能。</p> <p>很多其它流行面向对象的编程语言都是用继承来实现上述目的。两种实现方式有<a href="https://en.wikipedia.org/wiki/Composition_over_inheritance" target="_blank" rel="noopener noreferrer">它们各自的利弊<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。 这里，此篇文章将不讨论哪种方式更好一些，我们只需知道Go选择了类型内嵌这种方式。 这两种方式有一个很大的不同点：</p> <ul><li>如果类型<code>T</code>继承了另外一个类型，则类型<code>T</code>获取了另外一个类型的能力。 同时，一个<code>T</code>类型的值也可以被当作另外一个类型的值来使用。</li> <li>如果一个类型<code>T</code>内嵌了另外一个类型，则另外一个类型变成了类型<code>T</code>的一部分。 类型<code>T</code>获取了另外一个类型的能力，但是<code>T</code>类型的任何值都不能被当作另外一个类型的值来使用。</li></ul> <p>下面是一个展示了如何通过类型内嵌来扩展类型功能的例子：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>

<span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	Name <span class="token builtin">string</span>
	Age  <span class="token builtin">int</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>p Person<span class="token punctuation">)</span> <span class="token function">PrintName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;Name:&quot;</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span>Name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>Person<span class="token punctuation">)</span> <span class="token function">SetAge</span><span class="token punctuation">(</span>age <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	p<span class="token punctuation">.</span>Age <span class="token operator">=</span> age
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Singer <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	Person <span class="token comment">// 通过内嵌Person类型来扩展之</span>
	works  <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> gaga <span class="token operator">=</span> Singer<span class="token punctuation">{</span>Person<span class="token punctuation">:</span> Person<span class="token punctuation">{</span><span class="token string">&quot;Gaga&quot;</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
	gaga<span class="token punctuation">.</span><span class="token function">PrintName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Name: Gaga</span>
	gaga<span class="token punctuation">.</span>Name <span class="token operator">=</span> <span class="token string">&quot;Lady Gaga&quot;</span>
	<span class="token punctuation">(</span><span class="token operator">&amp;</span>gaga<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">SetAge</span><span class="token punctuation">(</span><span class="token number">31</span><span class="token punctuation">)</span>
	<span class="token punctuation">(</span><span class="token operator">&amp;</span>gaga<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">PrintName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">// Name: Lady Gaga</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>gaga<span class="token punctuation">.</span>Age<span class="token punctuation">)</span> <span class="token comment">// 31</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从上例中，当类型 <code>Singer</code> 内嵌了类型 <code>Person</code> 之后，看上去类型 <code>Singer</code> 获取了类型 <code>Person</code> 所有的字段和方法， 并且类型 <code>*Singer</code> 获取了类型 <code>*Person</code> 所有的方法。此结论是否正确？随后几节将给出答案。</p> <p>注意，类型 <code>Singer</code> 的一个值不能被当作 <code>Person</code> 类型的值用。下面的代码编译不通过：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">var</span> gaga <span class="token operator">=</span> Singer<span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> <span class="token boolean">_</span> Person <span class="token operator">=</span> gaga
</code></pre></div><h2 id="当一个结构体类型内嵌了另一个类型-此结构体类型是否获取了被内嵌类型的字段和方法"><a href="#当一个结构体类型内嵌了另一个类型-此结构体类型是否获取了被内嵌类型的字段和方法" class="header-anchor">#</a> 当一个结构体类型内嵌了另一个类型，此结构体类型是否获取了被内嵌类型的字段和方法？</h2> <p>下面这个程序使用<a href="https://gfw.go101.org/article/reflection.html" target="_blank" rel="noopener noreferrer">反射<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>列出了上一节的例子中的 <code>Singer</code> 类型的字段和方法，以及 <code>*Singer</code> 类型的方法。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">&quot;fmt&quot;</span>
	<span class="token string">&quot;reflect&quot;</span>
<span class="token punctuation">)</span>

<span class="token operator">...</span> <span class="token comment">// 为节省篇幅，上一个例子中声明的类型在这里省略了。</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	t <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span>Singer<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// the Singer type</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> <span class="token string">&quot;has&quot;</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span><span class="token function">NumField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;fields:&quot;</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> t<span class="token punctuation">.</span><span class="token function">NumField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">&quot; field#&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token string">&quot;: &quot;</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span><span class="token function">Field</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>Name<span class="token punctuation">,</span> <span class="token string">&quot;\n&quot;</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> <span class="token string">&quot;has&quot;</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span><span class="token function">NumMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;methods:&quot;</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> t<span class="token punctuation">.</span><span class="token function">NumMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">&quot; method#&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token string">&quot;: &quot;</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span><span class="token function">Method</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>Name<span class="token punctuation">,</span> <span class="token string">&quot;\n&quot;</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	pt <span class="token operator">:=</span> reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Singer<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// the *Singer type</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>pt<span class="token punctuation">,</span> <span class="token string">&quot;has&quot;</span><span class="token punctuation">,</span> pt<span class="token punctuation">.</span><span class="token function">NumMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;methods:&quot;</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pt<span class="token punctuation">.</span><span class="token function">NumMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">&quot; method#&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token string">&quot;: &quot;</span><span class="token punctuation">,</span> pt<span class="token punctuation">.</span><span class="token function">Method</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>Name<span class="token punctuation">,</span> <span class="token string">&quot;\n&quot;</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出结果：</p> <div class="language- extra-class"><pre class="language-text"><code>main.Singer has 2 fields:
 field#0: Person
 field#1: works
main.Singer has 1 methods:
 method#0: PrintName
*main.Singer has 2 methods:
 method#0: PrintName
 method#1: SetAge
</code></pre></div><p>从此输出结果中，我们可以看出类型 <code>Singer</code> 确实拥有一个 <code>PrintName</code> 方法，以及类型 <code>*Singer</code> 确实拥有两个方法： <code>PrintName</code> 和 <code>SetAge</code> 。 但是类型 <code>Singer</code> 并不拥有一个 <code>Name</code> 字段。那么为什么选择器表达式 <code>gaga. Name</code> 是合法的呢？ 毕竟 <code>gaga</code> 是 <code>Singer</code> 类型的一个值。 请阅读下一节以获取原因。</p> <h2 id="选择器的缩写形式"><a href="#选择器的缩写形式" class="header-anchor">#</a> 选择器的缩写形式</h2> <p>从前面的<a href="https://gfw.go101.org/article/struct.html" target="_blank" rel="noopener noreferrer">结构体<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>和<a href="https://gfw.go101.org/article/method.html" target="_blank" rel="noopener noreferrer">方法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>两篇文章中，我们得知，对于一个值 <code>x</code> ， <code>x.y</code> 称为一个选择器，其中 <code>y</code> 可以是一个字段名或者方法名。 如果 <code>y</code> 是一个字段名，那么 <code>x</code> 必须为一个结构体值或者结构体指针值。 一个选择器是一个表达式，它表示着一个值。 如果选择器 <code>x.y</code> 表示一个字段，此字段也可能拥有自己的字段（如果此字段的类型为另一个结构体类型）和方法，比如 <code>x.y.z</code> ，其中 <code>z</code> 可以是一个字段名，也可是一个方法名。</p> <p>在Go中，（不考虑下面将要介绍的选择器碰撞和遮挡），*<strong>如果一个选择器中的中部某项对应着一个内嵌字段，则此项可被省略掉*</strong>。 因此内嵌字段又被称为匿名字段。</p> <p>一个例子：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">type</span> A <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	x <span class="token builtin">int</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>a A<span class="token punctuation">)</span> <span class="token function">MethodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">type</span> B <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	A
<span class="token punctuation">}</span>
<span class="token keyword">type</span> C <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	B
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> c C

	<span class="token comment">// 下面的赋值语句中的选择器都是相互等价的。</span>
	<span class="token boolean">_</span> <span class="token operator">=</span> c<span class="token punctuation">.</span>B<span class="token punctuation">.</span>A<span class="token punctuation">.</span>x
	<span class="token boolean">_</span> <span class="token operator">=</span> c<span class="token punctuation">.</span>B<span class="token punctuation">.</span>x
	<span class="token boolean">_</span> <span class="token operator">=</span> c<span class="token punctuation">.</span>A<span class="token punctuation">.</span>x
	<span class="token boolean">_</span> <span class="token operator">=</span> c<span class="token punctuation">.</span>x <span class="token comment">// x被称为类型C的一个提升字段</span>

	<span class="token comment">// 这下面的几个方法调用都是互相等价的。</span>
	c<span class="token punctuation">.</span>B<span class="token punctuation">.</span>A<span class="token punctuation">.</span><span class="token function">MethodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	c<span class="token punctuation">.</span>B<span class="token punctuation">.</span><span class="token function">MethodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	c<span class="token punctuation">.</span>A<span class="token punctuation">.</span><span class="token function">MethodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	c<span class="token punctuation">.</span><span class="token function">MethodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这就是为什么在上一节的例子中选择器表达式 <code>gaga. Name</code> 是合法的， 因为它只不过是 <code>gaga. Person. Name</code> 的一个缩写形式。 <code>Name</code> 被称为类型 <code>Singer</code> 的提升字段（promoted field）。</p> <p>因为任何内嵌其它类型的类型必然是结构体类型，并且<a href="https://gfw.go101.org/article/struct.html#use-pointer-as-struct" target="_blank" rel="noopener noreferrer">结构体<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一文中已经知道了我们可以通过一个可寻址的结构体值的指针选择此结构体的字段，所以下面的代码也是合法的：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> c C
	pc <span class="token operator">=</span> <span class="token operator">&amp;</span>c

	<span class="token comment">// 这几行等价。</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>pc<span class="token punctuation">.</span>B<span class="token punctuation">.</span>A<span class="token punctuation">.</span>x<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>pc<span class="token punctuation">.</span>B<span class="token punctuation">.</span>x<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>pc<span class="token punctuation">.</span>A<span class="token punctuation">.</span>x<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>pc<span class="token punctuation">.</span>x<span class="token punctuation">)</span>

	<span class="token comment">// 这几行等价。</span>
	pc<span class="token punctuation">.</span>B<span class="token punctuation">.</span>A<span class="token punctuation">.</span><span class="token function">MethodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	pc<span class="token punctuation">.</span>B<span class="token punctuation">.</span><span class="token function">MethodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	pc<span class="token punctuation">.</span>A<span class="token punctuation">.</span><span class="token function">MethodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	pc<span class="token punctuation">.</span><span class="token function">MethodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>类似的，选择器 <code>gaga. PrintName</code> 可以被看作是 <code>gaga. Person. PrintName</code> 的缩写形式。 但是，我们也可以不把它看作是一个缩写。毕竟，类型 <code>Singer</code> 确实拥有一个 <code>PrintName</code> 方法， 尽管此方法是被隐式声明的（请阅读下下节以获得详情）。 同样的原因，选择器 <code>(&amp;gaga). PrintName</code> 和 <code>(&amp;gaga). SetAge</code> 可以看作（也可以不看作）是 <code>(&amp;gaga. Person). PrintName</code> 和 <code>(&amp;gaga. Person). SetAge</code> 的缩写。</p> <p>注意：我们也可以使用选择器 <code>gaga. SetAge</code> ，但是只有在 <code>gaga</code> 是一个可寻址的类型为 <code>Singer</code> 的值的情况下。 它只不过是 <code>(&amp;gaga). SetAge</code> 的一个<a href="https://gfw.go101.org/article/method.html#call" target="_blank" rel="noopener noreferrer">语法糖<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>在上面的例子中， <code>c. B. A.x</code> 称为选择器表达式 <code>c.x</code> 、 <code>c. B.x</code> 和 <code>c. A.x</code> 的完整形式。 类似的， <code>c. B. A. MethodA</code> 可以称为 <code>c. MethodA</code> 、 <code>c. B. MethodA</code> 和 <code>c. A. MethodA</code> 的完整形式。</p> <p>如果一个选择器的完整形式中的所有中部项均对应着一个内嵌字段，则中部项的数量称为此选择器的深度。 比如，上面的例子中的选择器 <code>c. MethodA</code> 的深度为<em>2</em>，因为此选择器的完整形式为 <code>c. B. A. MethodA</code> ，并且 <code>B</code> 和 <code>A</code> 都对应着一个内嵌字段。</p> <h2 id="选择器遮挡和碰撞"><a href="#选择器遮挡和碰撞" class="header-anchor">#</a> 选择器遮挡和碰撞</h2> <p>一个值 <code>x</code> （这里我们总认为它是可寻址的）可能同时拥有多个最后一项相同的选择器，并且这些选择器的中间项均对应着一个内嵌字段。 对于这种情形（假设最后一项为 <code>y</code> ）：</p> <ul><li>只有深度最浅的一个完整形式的选择器（并且最浅者只有一个）可以被缩写为<code>x.y</code>。 换句话说，<code>x.y</code>表示深度最浅的一个选择器。其它完整形式的选择器被此最浅者所遮挡（压制）。</li> <li>如果有多个完整形式的选择器同时拥有最浅深度，则任何完整形式的选择器都不能被缩写为<code>x.y</code>。 我们称这些同时拥有最浅深度的完整形式的选择器发生了碰撞。</li></ul> <p>如果一个方法选择器被另一个方法选择器所遮挡，并且它们对应的方法原型是一致的，那么我们可以说第一个方法被第二个覆盖（overridden）了。</p> <p>举个例子，假设 <code>A</code> 、 <code>B</code> 和 <code>C</code> 为三个<a href="https://gfw.go101.org/article/type-system-overview.html#non-defined-type" target="_blank" rel="noopener noreferrer">定义类型<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">type</span> A <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	x <span class="token builtin">string</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> B <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	y <span class="token builtin">bool</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>B<span class="token punctuation">)</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">type</span> C <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	B
<span class="token punctuation">}</span>
</code></pre></div><p>下面这段代码编译不通过，原因是选择器 <code>v1. A.x</code> 和 <code>v1. B.x</code> 的深度一样，所以它们发生了碰撞，结果导致它们都不能被缩写为 <code>v1.x</code> 。 同样的情况发生在选择器 <code>v1. A.y</code> 和 <code>v1. B.y</code> 身上。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">var</span> v1 <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	A
	B
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token boolean">_</span> <span class="token operator">=</span> v1<span class="token punctuation">.</span>x <span class="token comment">// error: 模棱两可的v1.x</span>
	<span class="token boolean">_</span> <span class="token operator">=</span> v1<span class="token punctuation">.</span>y <span class="token comment">// error: 模棱两可的v1.y</span>
<span class="token punctuation">}</span>
</code></pre></div><p>下面的代码编译没问题。选择器 <code>v2. C. B.x</code> 被另一个选择器 <code>v2. A.x</code> 遮挡了，所以 <code>v2.x</code> 实际上是选择器 <code>v2. A.x</code> 的缩写形式。 因为同样的原因， <code>v2.y</code> 是选择器 <code>v2. A.y</code> （而不是选择器 <code>v2. C. B.y</code> ）的缩写形式。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">var</span> v2 <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	A
	C
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;%T \n&quot;</span><span class="token punctuation">,</span> v2<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token comment">// string</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">&quot;%T \n&quot;</span><span class="token punctuation">,</span> v2<span class="token punctuation">.</span>y<span class="token punctuation">)</span> <span class="token comment">// func(int) bool</span>
<span class="token punctuation">}</span>
</code></pre></div><p>一个被遮挡或者碰撞的选择器并不妨碍更深层的选择器被提升，如下例所示中的 <code>. M</code> 和 <code>.z</code> ：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">type</span> x <span class="token builtin">string</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token function">M</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">type</span> y <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	z <span class="token builtin">byte</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> A <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	x
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>A<span class="token punctuation">)</span> <span class="token function">y</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> B <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	y
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>B<span class="token punctuation">)</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> v <span class="token keyword">struct</span> <span class="token punctuation">{</span>
		A
		B
	<span class="token punctuation">}</span>
	<span class="token comment">//_ = v.x // error: 模棱两可的v.x</span>
	<span class="token comment">//_ = v.y // error: 模棱两可的v.y</span>
	<span class="token boolean">_</span> <span class="token operator">=</span> v<span class="token punctuation">.</span>M <span class="token comment">// ok. &lt;=&gt; v.A.x.M</span>
	<span class="token boolean">_</span> <span class="token operator">=</span> v<span class="token punctuation">.</span>z <span class="token comment">// ok. &lt;=&gt; v.B.y.z</span>
<span class="token punctuation">}</span>
</code></pre></div><p>一个不寻常的但需要注意的细节是：来自不同库包的两个非导出方法（或者字段）将总是被认为是两个不同的标识符，即使它们的名字完全一致。 因此，当它们的属主类型被同时内嵌在同一个结构体类型中的时候，它们绝对不会相互碰撞或者遮挡。 举个例子，下面这个含有两个库包的Go程序编译和运行都没问题。 但是，如果将其中所有出现的 <code>m()</code> 改为 <code>M()</code> ，则此程序将编译不过。 原因是 <code>A. M</code> 和 <code>B. M</code> 碰撞了，导致 <code>c. M</code> 为一个非法的选择器。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> foo <span class="token comment">// import &quot;x.y/foo&quot;</span>

<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>

<span class="token keyword">type</span> A <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	n <span class="token builtin">int</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>a A<span class="token punctuation">)</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;A&quot;</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>n<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> I <span class="token keyword">interface</span> <span class="token punctuation">{</span>
	<span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">Bar</span><span class="token punctuation">(</span>i I<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	i<span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>
<span class="token keyword">import</span> <span class="token string">&quot;x.y/foo&quot;</span>

<span class="token keyword">type</span> B <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	n <span class="token builtin">bool</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>b B<span class="token punctuation">)</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;B&quot;</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>n<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> C <span class="token keyword">struct</span><span class="token punctuation">{</span>
	foo<span class="token punctuation">.</span>A
	B
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> c C
	c<span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token comment">// B false</span>
	foo<span class="token punctuation">.</span><span class="token function">Bar</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token comment">// A 0</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="为内嵌了其它类型的结构体类型声明的隐式方法"><a href="#为内嵌了其它类型的结构体类型声明的隐式方法" class="header-anchor">#</a> 为内嵌了其它类型的结构体类型声明的隐式方法</h2> <p>上面已经提到过，类型 <code>Singer</code> 和 <code>*Singer</code> 都有一个 <code>PrintName</code> 方法，并且类型 <code>*Singer</code> 还有一个 <code>SetAge</code> 方法。 但是，我们从没有为这两个类型声明过这几个方法。这几个方法从哪来的呢？</p> <p>事实上，假设结构体类型 <code>S</code> 内嵌了一个类型（或者类型别名） <code>T</code> ，并且此内嵌是合法的，</p> <ul><li>对内嵌类型<code>T</code>的每一个方法，如果此方法对应的选择器既不和其它选择器碰撞也未被其它选择器遮挡，则编译器将会隐式地为结构体类型<code>S</code>声明一个同样原型的方法。 继而，编译器也将为指针类型<code>*S</code><a href="https://gfw.go101.org/article/method.html#implicit-pointer-methods" target="_blank" rel="noopener noreferrer">隐式声明<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一个相应的方法。</li> <li>对类型<code>*T</code>的每一个方法，如果此方法对应的选择器既不和其它选择器碰撞也未被其它选择器遮挡，则编译器将会隐式地为类型<code>*S</code>声明一个同样原型的方法。</li></ul> <p>简单说来，</p> <ul><li>类型<code>struct{T}</code>和<code>*struct{T}</code>均将获取类型<code>T</code>的所有方法。</li> <li>类型<code>*struct{T}</code>、<code>struct{*T}</code>和<code>*struct{*T}</code>都将获取类型<code>*T</code>的所有方法。</li></ul> <p>下面展示了编译器为类型 <code>Singer</code> 和 <code>*Singer</code> 隐式声明的三个方法：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">func</span> <span class="token punctuation">(</span>s Singer<span class="token punctuation">)</span> <span class="token function">PrintName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	s<span class="token punctuation">.</span>Person<span class="token punctuation">.</span><span class="token function">PrintName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">// 编译器在这里会做一个优化。对于一个</span>
	<span class="token comment">// 传递给形参s的实参来说，只有它的</span>
	<span class="token comment">// Person部分将在传参过程中被复制。</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>Singer<span class="token punctuation">)</span> <span class="token function">PrintName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token punctuation">(</span><span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">.</span>Person<span class="token punctuation">.</span><span class="token function">PrintName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>Singer<span class="token punctuation">)</span> <span class="token function">SetAge</span><span class="token punctuation">(</span>age <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">.</span>Person<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">SetAge</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span>
	<span class="token comment">// &lt;=&gt; (&amp;((*s).Person)).SetAge(age)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>隐式方法亦称提升方法（promoted method）。</p> <p>从<a href="https://gfw.go101.org/article/method.html" target="_blank" rel="noopener noreferrer">方法<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一文中，我们得知我们不能为非定义的结构体类型（和基类型为非定义结构体类型的指针类型）声明方法。 但是，通过类型内嵌，这样的类型也可以拥有方法。</p> <p>下面是另一个证明了类型内嵌导致了一些方法被隐式声明的例子：</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>
<span class="token keyword">import</span> <span class="token string">&quot;reflect&quot;</span>

<span class="token keyword">type</span> F <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>f F<span class="token punctuation">)</span> <span class="token function">Validate</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>f <span class="token operator">*</span>F<span class="token punctuation">)</span> <span class="token function">Modify</span><span class="token punctuation">(</span>f2 F<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token operator">*</span>f <span class="token operator">=</span> f2
<span class="token punctuation">}</span>

<span class="token keyword">type</span> B <span class="token builtin">bool</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>b B<span class="token punctuation">)</span> <span class="token function">IsTrue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token function">bool</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>pb <span class="token operator">*</span>B<span class="token punctuation">)</span> <span class="token function">Invert</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token operator">*</span>pb <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">*</span>pb
<span class="token punctuation">}</span>

<span class="token keyword">type</span> I <span class="token keyword">interface</span> <span class="token punctuation">{</span>
	<span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token function">Save</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">PrintTypeMethods</span><span class="token punctuation">(</span>t reflect<span class="token punctuation">.</span>Type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> <span class="token string">&quot;has&quot;</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span><span class="token function">NumMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;methods:&quot;</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> t<span class="token punctuation">.</span><span class="token function">NumMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token string">&quot; method#&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token string">&quot;: &quot;</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span><span class="token function">Method</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>Name<span class="token punctuation">,</span> <span class="token string">&quot;\n&quot;</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> s <span class="token keyword">struct</span> <span class="token punctuation">{</span>
		F
		<span class="token operator">*</span>B
		I
	<span class="token punctuation">}</span>

	<span class="token function">PrintTypeMethods</span><span class="token punctuation">(</span>reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token function">PrintTypeMethods</span><span class="token punctuation">(</span>reflect<span class="token punctuation">.</span><span class="token function">TypeOf</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>输出结果：</p> <div class="language- extra-class"><pre class="language-text"><code>struct { main.F; *main.B; main.I } has 5 methods:
 method#0: Invert
 method#1: IsTrue
 method#2: Load
 method#3: Save
 method#4: Validate

*struct { main.F; *main.B; main.I } has 6 methods:
 method#0: Invert
 method#1: IsTrue
 method#2: Load
 method#3: Modify
 method#4: Save
 method#5: Validate
</code></pre></div><p>如果一个结构体类型内嵌了一个实现了一个接口类型的类型（此内嵌类型可以是此接口类型自己），则一般说来，此结构体类型也实现了此接口类型，除非发生了选择器碰撞和遮挡。 比如，上例中的结构体类型和以它为基类型的指针类型均实现了接口类型 <code>I</code> 。</p> <p>请注意：一个类型将只会获取它（直接或者间接）内嵌了的类型的方法。 换句话说，一个类型的方法集由为类型直接（显式或者隐式）声明的方法和此类型的底层类型的方法集组成。 比如，在下面的例子中，</p> <ul><li>类型<code>Age</code>没有方法，因为代码中既没有为它声明任何方法，它也没有内嵌任何类型，。</li> <li>类型<code>X</code>有两个方法：<code>IsOdd</code>和<code>Double</code>。 其中<code>IsOdd</code>方法是通过内嵌类型<code>MyInt</code>而得来的。</li> <li>类型<code>Y</code>没有方法，因为它所内嵌的类型<code>Age</code>没有方法，另外代码中也没有为它声明任何方法。</li> <li>类型<code>Z</code>只有一个方法：<code>IsOdd</code>。 此方法是通过内嵌类型<code>MyInt</code>而得来的。 它没有获取到类型<code>X</code>的<code>Double</code>方法，因为它并没有内嵌类型<code>X</code>。</li></ul> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">type</span> MyInt <span class="token builtin">int</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>mi MyInt<span class="token punctuation">)</span> <span class="token function">IsOdd</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> mi<span class="token operator">%</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Age MyInt

<span class="token keyword">type</span> X <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	MyInt
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>x X<span class="token punctuation">)</span> <span class="token function">Double</span><span class="token punctuation">(</span><span class="token punctuation">)</span> MyInt <span class="token punctuation">{</span>
	<span class="token keyword">return</span> x<span class="token punctuation">.</span>MyInt <span class="token operator">+</span> x<span class="token punctuation">.</span>MyInt
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Y <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	Age
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Z X
</code></pre></div><h2 id="接口类型内嵌接口类型"><a href="#接口类型内嵌接口类型" class="header-anchor">#</a> 接口类型内嵌接口类型</h2> <p>不但结构体类型可以内嵌类型，接口类型也可以内嵌类型。但是接口类型只能内嵌接口类型。详情请阅读<a href="https://gfw.go101.org/article/interface.html#embedding" target="_blank" rel="noopener noreferrer">接口<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一文。</p> <h2 id="一个有趣的类型内嵌的例子"><a href="#一个有趣的类型内嵌的例子" class="header-anchor">#</a> 一个有趣的类型内嵌的例子</h2> <p>在本文的最后，让我们来看一个有趣的例子。 此例子程序将陷入死循环并会因堆栈溢出而崩溃退出。 如果你已经理解了<a href="https://gfw.go101.org/article/interface.html#polymorphism" target="_blank" rel="noopener noreferrer">多态<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>和类型内嵌，那么就不难理解为什么此程序将死循环。</p> <div class="language-go extra-class"><pre class="language-go"><code><span class="token keyword">package</span> main

<span class="token keyword">type</span> I <span class="token keyword">interface</span> <span class="token punctuation">{</span>
	<span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> T <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	I
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> t T
	<span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token operator">&amp;</span>t
	t<span class="token punctuation">.</span>I <span class="token operator">=</span> i
	i<span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 将调用t.m()，然后再次调用i.m()，......</span>
<span class="token punctuation">}</span>
</code></pre></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">5/21/2021, 1:25:38 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/开发基础/GO/Go类型系统/8接口.html" class="prev">
        接口
      </a></span> <span class="next"><a href="/blog/开发基础/GO/Go类型系统/10非类型安全指针.html">
        非类型安全指针
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.4c58f1db.js" defer></script><script src="/blog/assets/js/3.a4fcd0ee.js" defer></script><script src="/blog/assets/js/117.037382b2.js" defer></script>
  </body>
</html>
